//! Build script to auto-generate templates.rs and analyzer detection from templates folder
//!
//! This scans the `templates/` submodule at compile time and generates Rust code
//! that embeds all gitignore templates.

use std::env;
use std::fs::{self, File};
use std::io::Write;
use std::path::Path;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let templates_dir = Path::new("templates");

    // Collect all .gitignore files
    let mut templates: Vec<(String, String)> = Vec::new();

    if templates_dir.exists() {
        collect_templates(templates_dir, &mut templates, "");
    }

    // Sort templates by name for consistent output
    templates.sort_by(|a, b| a.0.to_lowercase().cmp(&b.0.to_lowercase()));

    // Generate templates.rs
    generate_templates_file(&out_dir, &templates);

    // Tell cargo to rerun if templates change
    println!("cargo:rerun-if-changed=templates");
}

fn collect_templates(dir: &Path, templates: &mut Vec<(String, String)>, prefix: &str) {
    if let Ok(entries) = fs::read_dir(dir) {
        for entry in entries.filter_map(|e| e.ok()) {
            let path = entry.path();
            let name = entry.file_name().to_string_lossy().to_string();

            // Skip hidden files and directories
            if name.starts_with('.') {
                continue;
            }

            if path.is_dir() {
                // Recurse into subdirectories (Global, community, etc.)
                let new_prefix =
                    if prefix.is_empty() { name.clone() } else { format!("{}/{}", prefix, name) };
                collect_templates(&path, templates, &new_prefix);
            } else if name.ends_with(".gitignore") {
                // Extract template name (remove .gitignore extension)
                let template_name = name.trim_end_matches(".gitignore").to_string();
                let full_name = if prefix.is_empty() {
                    template_name
                } else {
                    format!("{}/{}", prefix, template_name)
                };

                let relative_path = path.to_string_lossy().replace('\\', "/");
                templates.push((full_name, relative_path));
            }
        }
    }
}

fn generate_templates_file(out_dir: &str, templates: &[(String, String)]) {
    let dest_path = Path::new(out_dir).join("templates_gen.rs");
    let mut file = File::create(&dest_path).expect("Failed to create templates_gen.rs");

    // Write header
    writeln!(file, "// Auto-generated template loader. DO NOT EDIT.").unwrap();
    writeln!(file, "// Generated by build.rs from templates/ submodule.").unwrap();
    writeln!(file).unwrap();
    writeln!(file, "use std::collections::HashMap;").unwrap();
    writeln!(file, "use once_cell::sync::Lazy;").unwrap();
    writeln!(file).unwrap();

    // Generate static map
    writeln!(file, "// All available gitignore templates").unwrap();
    writeln!(
        file,
        "pub static TEMPLATES: Lazy<HashMap<&'static str, &'static str>> = Lazy::new(|| {{"
    )
    .unwrap();

    writeln!(file, "    #[allow(unused_mut)]").unwrap();
    writeln!(file, "    let mut m = HashMap::new();").unwrap();

    for (name, path) in templates {
        let key = name.to_lowercase().replace('/', "_");
        writeln!(
            file,
            r#"    m.insert("{}", include_str!(concat!(env!("CARGO_MANIFEST_DIR"), "/{}")));"#,
            key, path
        )
        .unwrap();
    }

    writeln!(file, "    m").unwrap();
    writeln!(file, "}});").unwrap();
    writeln!(file).unwrap();

    // Generate list function
    writeln!(file, "// List all available template names").unwrap();
    writeln!(file, "pub fn list_templates() -> Vec<&'static str> {{").unwrap();
    writeln!(file, "    vec![").unwrap();
    for (name, _) in templates {
        writeln!(file, r#"        "{}","#, name).unwrap();
    }
    writeln!(file, "    ]").unwrap();
    writeln!(file, "}}").unwrap();
    writeln!(file).unwrap();

    // Generate get function
    writeln!(file, "// Get a template by name (case-insensitive)").unwrap();
    writeln!(file, "pub fn get_template(name: &str) -> Option<&'static str> {{").unwrap();
    writeln!(file, "    let key = name.to_lowercase().replace('/', \"_\");").unwrap();
    writeln!(file, "    TEMPLATES.get(key.as_str()).copied()").unwrap();
    writeln!(file, "}}").unwrap();
}
